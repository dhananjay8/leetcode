ğ—”ğ—¿ğ—¿ğ—®ğ˜†ğ˜€ ğ—®ğ—»ğ—± ğ—¦ğ˜ğ—¿ğ—¶ğ—»ğ—´ğ˜€:
1. Find the maximum sum subarray.
2. Find all substrings that are palindromes.
3. Implement the "two sum" problem.
4. Implement Kadane's algorithm for maximum subarray sum.
5. Find the missing number in an array of integers.
6. Merge two sorted arrays into one sorted array.
7. Check if a string is a palindrome.
8. Find the first non-repeating character in a string.
9. Write a program to remove duplicates from a sorted array.

ğ—Ÿğ—¶ğ—»ğ—¸ğ—²ğ—± ğ—Ÿğ—¶ğ˜€ğ˜ğ˜€:
10. Reverse a linked list.
11. Detect a cycle in a linked list.
12. Find the middle of a linked list.
13. Merge two sorted linked lists.
14. Implement a stack using linked list.
15. Find the intersection point of two linked lists.

ğ—¦ğ˜ğ—®ğ—°ğ—¸ğ˜€ ğ—®ğ—»ğ—± ğ—¤ğ˜‚ğ—²ğ˜‚ğ—²ğ˜€:
16. Implement a stack using an array.
17. Implement a stack that supports push, pop, top, and retrieving the minimum element.
18. Implement a circular queue.
19. Design a max stack that supports push, pop, top, retrieve maximum element.
20. Design a queue using stacks.

ğ—§ğ—¿ğ—²ğ—²ğ˜€ ğ—®ğ—»ğ—± ğ—•ğ—¶ğ—»ğ—®ğ—¿ğ˜† ğ—¦ğ—²ğ—®ğ—¿ğ—°ğ—µ ğ—§ğ—¿ğ—²ğ—²ğ˜€:
21. Find the height of a binary tree.
22. Find the lowest common ancestor of two nodes in a binary tree.
23. Validate if a binary tree is a valid binary search tree.
24. Serialize and deserialize a binary tree.
25. Implement an inorder traversal of a binary tree.
26. Find the diameter of a binary tree.
27. Convert a binary tree to its mirror tree.

ğ—šğ—¿ğ—®ğ—½ğ—µğ˜€:
28. Implement depth-first search (DFS).
29. Implement breadth-first search (BFS).
30. Find the shortest path between two nodes in an unweighted graph.
31. Detect a cycle in an undirected graph using DFS.
32. Check if a graph is bipartite.
33. Find the number of connected components in an undirected graph.
34. Find bridges in a graph.

ğ—¦ğ—¼ğ—¿ğ˜ğ—¶ğ—»ğ—´ ğ—®ğ—»ğ—± ğ—¦ğ—²ğ—®ğ—¿ğ—°ğ—µğ—¶ğ—»ğ—´:
35. Implement (bubble, insertion, selection, merge) sort.
36. Implement quicksort.
37. Implement binary search.
38. Implement interpolation search.
39. Find the kth smallest element in an array.
40. Given an array of integers, count the number of inversions it has. An inversion occurs when two elements in the array are out of order.

ğ——ğ˜†ğ—»ğ—®ğ—ºğ—¶ğ—° ğ—£ğ—¿ğ—¼ğ—´ğ—¿ğ—®ğ—ºğ—ºğ—¶ğ—»ğ—´ (ğ——ğ—£):
1. How do you find the nth Fibonacci number using dynamic programming?
2. Write a dynamic programming solution for the 0/1 knapsack problem.
3. Memoization to optimize recursive solutions in dynamic programming?
4. Implement a dynamic programming algorithm to find the longest common subsequence of two strings.
5. The coin change problem.
6. Tabulation approach in dynamic programming.

ğ—•ğ—®ğ—°ğ—¸ğ˜ğ—¿ğ—®ğ—°ğ—¸ğ—¶ğ—»ğ—´:
7. Backtracking algorithm to solve the N-Queens problem.
8. Generate all permutations of a given set using backtracking?
9. Implement backtracking to solve the Sudoku puzzle.
10. Subset sum problem.
11. Graph coloring problem using backtracking.
12. Write a backtracking algorithm to find the Hamiltonian cycle in a graph.

ğ—›ğ—®ğ˜€ğ—µğ—¶ğ—»ğ—´:
13. Implement a hash table using separate chaining.
14. First non-repeating character in a string using hashing.
15. Collision resolution techniques in hashing.
16. Write a function to solve the two-sum problem using hashing.
17. How can you implement a hash set data structure?
18. Count the frequency of elements in an array using hashing.

ğ—›ğ—²ğ—®ğ—½:
19. Implement a priority queue using a min-heap.
20. How do you merge K sorted arrays using a min-heap?
21. Write a function to perform heap sort algorithm.
22. Find the kth largest element in an array using a min-heap.
23. Implement a priority queue using a min-heap.
24. How do you build a max heap from an array?

ğ—§ğ—¿ğ—¶ğ—²ğ˜€:
25. Implement a trie data structure.
26. Write a function to search for a word in a trie.
27. How can you implement autocomplete feature using a trie?
28. Deleting a word from a trie.
30. Write a function to find all words matching a pattern in a trie.

ğ—šğ—¿ğ—²ğ—²ğ—±ğ˜† ğ—”ğ—¹ğ—´ğ—¼ğ—¿ğ—¶ğ˜ğ—µğ—ºğ˜€:
31. Solve the activity selection problem using a greedy algorithm.
32. Implement Huffman coding using a greedy algorithm.
33. Write a function to find the minimum spanning tree using Prim's algorithm.
34. Coin change problem.
35. Dijkstra's algorithm using a greedy approach.
36. Implement the job sequencing problem using a greedy algorithm.


37. Stack Vs queue.
38. breadth-first search (BFS) and depth-first search (DFS) traversal 
39. Concept of big O notation.
40. What is an AVL tree? Explain its properties and how it maintains balance during insertion and deletion operations.


ğŸ­. ğ—”ğ—¿ğ—¿ğ—®ğ˜†ğ˜€ & ğ—¦ğ˜ğ—¿ğ—¶ğ—»ğ—´ğ˜€
- Minimum Window Substring
- Trapping Rain Water
- Largest Rectangle in Histogram

ğŸ®. ğ—Ÿğ—¶ğ—»ğ—¸ğ—²ğ—± ğ—Ÿğ—¶ğ˜€ğ˜ğ˜€
- Merge k Sorted Lists
- Reverse Nodes in k-Group
- LFU Cache

ğŸ¯. ğ—§ğ—¿ğ—²ğ—²ğ˜€
- Binary Tree Maximum Path Sum
- Serialize and Deserialize Binary Tree
- Vertical Order Traversal of a Binary Tree

ğŸ°. ğ——ğ˜†ğ—»ğ—®ğ—ºğ—¶ğ—° ğ—£ğ—¿ğ—¼ğ—´ğ—¿ğ—®ğ—ºğ—ºğ—¶ğ—»ğ—´
- Edit Distance
- Burst Balloons
- Shortest Common Supersequence

ğŸ±. ğ—šğ—¿ğ—®ğ—½ğ—µğ˜€
- Alien Dictionary
- Minimum Cost to Make at Least One Valid Path in a Grid
- Swim in Rising Water

ğŸ². ğ—¥ğ—²ğ—°ğ˜‚ğ—¿ğ˜€ğ—¶ğ—¼ğ—» & ğ—•ğ—®ğ—°ğ—¸ğ˜ğ—¿ğ—®ğ—°ğ—¸ğ—¶ğ—»ğ—´
- N-Queens II
- Sudoku Solver
- Word Search II

ğŸ³. ğ—¦ğ—¼ğ—¿ğ˜ğ—¶ğ—»ğ—´ & ğ—¦ğ—²ğ—®ğ—¿ğ—°ğ—µğ—¶ğ—»ğ—´
- Count of Smaller Numbers After Self
- Median of Two Sorted Arrays
- Split Array Largest Sum

ğŸ´. ğ——ğ—²ğ˜€ğ—¶ğ—´ğ—»
- Design Search Autocomplete System
- Design In-Memory File System
- Design Excel Sum Formula

ğŸµ. ğ—šğ—¿ğ—²ğ—²ğ—±ğ˜†
- Minimum Number of Arrows to Burst Balloons
- Candy
- Patching Array

ğŸ­ğŸ¬. ğ—•ğ—¶ğ˜ ğ— ğ—®ğ—»ğ—¶ğ—½ğ˜‚ğ—¹ğ—®ğ˜ğ—¶ğ—¼ğ—»
- Maximum Product of Word Lengths
- Smallest Sufficient Team
- Minimum Cost to Connect Two Groups of Points

ğŸ­ğŸ­. ğ—§ğ˜„ğ—¼ ğ—£ğ—¼ğ—¶ğ—»ğ˜ğ—²ğ—¿ğ˜€
- Minimum Window Subsequence
- Minimum Operations to Make a Subsequence
- Minimum Adjacent Swaps to Reach the Kth Smallest Number

ğŸ­ğŸ®. ğ—›ğ—²ğ—®ğ—½
- Minimum Number of Refueling Stops
- Sliding Window Median
- Minimum Number of K Consecutive Bit Flips